# password
[참고](https://st-lab.tistory.com/100)

해싱과 암호화는 일상에서는 어느정도 통용되지만, 암호학적으로 본다면 차이가 있다. 가장 큰 차이는 '방향성'이다. 단방향, 즉 복호화가 불가능하는 하다는 것이고 이를 '해싱'이라 부른다. 반면에 '암호화(Encryption)'는 해싱하고는 다르다. '암호화'는 '양방향'이다. 즉, 암호화를 하면 역으로 복호화도 가능한 것이다. 

## 단방향 해시 함수 ( One-Way Hash Function )
    단방향 해시 함수는 어떤 수학적 연산(또는 알고리즘)에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것을 의미한다. 이 변환을 해시라고 하고, 해시에 의해 암호화된 데이터를 다이제스트(digest)라고 한다.

단방향 해시 함수 - 다이제스트를 복호화, 즉 원본 데이터를 구할 수는 없어야 한다. 말 그대로 단방향성이다.


세계에서 가장 인기있는 비밀번호인 123456을 예로들어보자.

간단하게 그림으로 설명한다면 다음과 같다.

<img src="../../assets/pw1.png" width=400px>

즉 원본 메시지 123456 을 해시 함수에 돌려서 다이제스트인 fs32a3xzz0 을 생성하고 해당 데이터를 DB 에 저장하는 것이다.

이렇게 저장된 다이제스트는 설령 DB가 털린다 하더라도 fs32a3xzz0 은 단방향으로 해싱 된 문자라 복호화 할 수가 없는 것이다. 또한 의미를 파악할 수도 없다.

이러한 단방향 해시 함수의 종류들은 매우 많다. 대표적으로 아래와 같은 알고리즘들이 있다.

SHA
MD
HAS
WHIRLPOOL
 
그중 가장 대표적인 해시 알고리즘인 SHA-256 을 통해 123456 을 해싱하면 다음과 같이 나온다.

`8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92`

만약 조금만 변경하여 123456 다음에 마침표(.) 하나만 더 찍어도 완전히 다른 값이 나온다.

`43fae6c11d7632acc6059de1cced9b09a58caaa878071308ad67f32ef6b11691`
 


이렇게 사용자로부터 입력받은 정보를 그대로 저장하는게 아니라 해싱을 해서 저장하는 것이다.

그러면 DB를 털어 저런 값을 얻었다고 한들 기존 원래 패스워드를 유추하기 힘들게 된다.

### 단방향 해시 함수의 한계점

1. 동일한 메시지는 동일한 다이제스트를 갖는다.

앞서 위의 123456 을 SHA-256 을 통해 다이제스트를 얻었다. 분명 123456 의 다이제스트는 원래의 password 인 123456 을 유추하기 어렵다. 그러나 123456 에 대한 다이제스트는 항상 같은 값을 얻는다는 것, 즉 값이 변하지 않는 것이 큰 문제점이다.

여러분이 해커(공격자)라고 가정해볼 때 해싱된 메시지의 원문을 얻기 위해서 가장 편한 방법은 무엇일까?

그 것은 바로 그동안 해커들이 여러 값들을 대입해보면서 얻었던 다이제스트들을 모아놓은 리스트에서 찾아보는 것이다. 이러한 다이제스트들의 테이블을 우리는 레인보우 테이블(Rainbow Table)이라고 한다.

구글에 'sha-256 rainbow table' 라고 검색해보면 여러 사이트가 있다.

우리가 123456 은 모른다고 가정하에 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 만 갖고 한 번 찾아보자.

sha-256 rainbow table 라고 구글링하여 한 사이트에 해당 해시값을 넣고 돌려봤더니 1초도 안되어서 Type 과 결과까지 나온다.

### 2. 무차별 대입 공격 (브루트포스)

해시 함수의 경우 원래 빠른 데이터 검색을 위한 목적으로 설계된 것이다. 그렇다보니 해시 함수를 써도 원문의 다이제스트는 금방 얻어진다. 바로 이 점이 문제점인데, 우리가 다이제스트를 빠르게 얻을 수 있는 것과 동일하게 해커도 똑같이 빠르게 값을 얻을 수 있다는 것이다. 즉, 해커는 무작위의 데이터들을 계속 대입해보면서 얻은 다이제스트와 해킹할 대상의 다이제스트를 계속 비교를 해보는 것이다.

해시를 통한 다이제스트 값을 빠르게 얻을 수 있는 만큼 해커입장에서는 좋을 수 밖에 없다.

 
물론 모든 값을 다 대입하기는 시간적으로 여유가 없다.

그럼 SHA-256 을 완전히 해독하려면 얼마나 걸릴까?

StackOverFlow 커뮤니티 글을 찾아보니 라데온 Radeon HD5830 에서 초당 대략 6억번의 SHA-256 을 수행할 수 있다고한다.


그냥 1초당 10억 번 이라고 가정해보자.

256 개의 비트가 있다는 의미이므로 경우의 수는

2256 = 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,936

확률적으로 매우 높은 확률로 해시충돌을 찾을 수 있다. (물론 그럼에도 찾기 힘들긴 하지만... 실제로도 SHA-1의 경우 2000년대 초에 많이 사용하던 대표적인 해시 알고리즘이었지만 SHA-1을 분석해 이론적으로 해시충돌을 찾는 복잡도를 낮췄고 2017년 실제로 해시충돌 발견에 성공했다. 그래서 많은 곳들이 SHA-2 이상의 알고리즘으로 변경되면서 사실상 거의 퇴출되었다.