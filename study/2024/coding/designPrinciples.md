# 디자인 원리

SOLID 원칙은 소프트웨어 개발자가 유지 관리 가능하고 확장 가능하며 유연한 소프트웨어 시스템을 만들 수 있도록 안내하기 위해 Robert C. Martin이 도입한 5가지 기본 설계 원칙 세트입니다. 이러한 원칙을 따르면 시간이 지남에 따라 더 쉽게 이해하고 수정하고 확장할 수 있는 소프트웨어 개발에 기여할 수 있습니다.

![](images/designPrinciples1.png)

- 유지 관리성: Maintainability:건전한 디자인 원칙을 따르면 코드의 유지 관리가 더욱 쉬워집니다. 코드가 잘 구조화되어 있고 이러한 원칙을 준수하면 문제를 식별 및 수정하고, 새로운 기능을 추가하고, 의도하지 않은 결과를 초래하지 않고 개선하는 것이 더 쉬워집니다.

- 확장성: Scalability:잘 설계된 소프트웨어는 확장 가능합니다. 광범위한 재작업을 요구하거나 점점 더 복잡해지지 않고도 요구사항의 변화와 증가를 수용할 수 있습니다.

- 코드 재사용성: Code Reusability:설계 원칙을 준수하면 재사용성이 더 높은 코드를 얻을 수 있는 경우가 많습니다. 재사용 가능한 구성 요소는 개발 및 테스트에 소요되는 시간과 노력을 절약해 줍니다.

- 협업: Collaboration:디자인 원칙은 개발자가 작업할 수 있는 공통 프레임워크를 제공합니다. 이러한 공통된 이해는 협업을 촉진하고 팀원 간의 오해를 줄여줍니다.

- 버그 및 함정 감소: Reduced Bugs and Pitfalls:설계 원칙을 따르면 일반적인 프로그래밍 함정과 설계 결함을 식별하고 완화하는 데 도움이 됩니다. 결과적으로 버그가 줄어들고 소프트웨어가 더욱 강력해집니다.

- 미래 보장: Future-Proofing: 잘 설계된 소프트웨어는 변화하는 요구 사항과 기술에 적응할 수 있습니다. 이는 소프트웨어 제품의 장기적인 생존 가능성에 대한 투자입니다.

<br>

---

<br>

### 단일 책임 원칙 (Single Responsibility Principle, SRP)

    각 클래스는 오직 하나의 목적을 위해 생성되어야 한다. 클래스가 여러 목적을 가지는 경우, 해당 클래스의 의존도가 높아지며, 구조가 복잡해져, 설계가 어려워질 수 있다.

    예를들어, 사칙 연산을 하는 계산 클래스는 오직 계산 기능만 책임을 지므로, 계산 관련 기능에만 명확하게 분업하여 사용되며, 대대적인 수정이 이루어지더라도 영향은 계산 관련 기능에만 미치므로, 불필요한 에러를 예방할 수 있다. 5원칙의 가장 메인이 되는 원칙이며, 남은 4원칙의 근간이 되는 원칙이다.

### 개방/폐쇄 원칙 (Open/Closed Principle, OCP)

    각 클래스는 확장에는 개방적이어야 하고, 수정에는 폐쇄적이어야 한다. 새로운 기능을 추가할 때, 기존의 코드에 영향을 미치지 않으며, 기능을 추가할 수 있도록 하는 것을 의미한다. (클래스간 응집도는 높이며, 결합도는 낮추기 위함)

### 리스코프 치환 원칙 (Liskov Subsititution Principle, LSP)

    자식 클래스는 언제나 부모 클래스로 대체할 수 있어야 함을 의미한다. 즉 부모 클래스가 들어갈 자리에 자식 클래스르 넣어도 정상적으로 프로그램이 작동해야함을 의미한다. 상속의 본질을 중요시 하며, 이를 지키지 않는 경우 부모 클래스 본래의 의미가 변해서 다형성을 보장할 수 없다.

    예를 들어, 우리가 컴퓨터에 연결하여 사용하는 마우스는, 어떤 마우스를 컴퓨터에 연결하든 왼쪽 클릭, 휠, 오른쪽 클릭 등을 공통적으로 가지고 있기에 행여 새로운 마우스가 등장하더라도 바로 사용이 가능하다. 그러나 마우스 대신 트랙패드를 사용하는 경우에는 처음 접하는 사람은 평소와 사용방식이 달라, 적응하는데 시간이 필요할 것이다. 이는, LSP 를 잘 지키지 못했다 할 수 있다.

### 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

    클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 즉 공통사항을 정의하는데 있어, 하나의 큰 인터페이스 보다는, 다수의 구체적인 인터페이스로 나누는 것이 좋다는 것이다.

    예를들어 캐릭터 충돌 시 이펙트가 나타나는 액션 게임 기능을 만든다고 가정하자. 이를 하나의 인터페이스로 만들어 처리하는 것도 가능하지만, 이펙트만 나타나야하거나 캐릭터의 충돌만 일어나는 경우가 생긴다면, 불필요한 충돌, 이펙트 데이터를 보내야 하는 문제가 발생한다. 따라서, 충돌과 이펙트를 2개의 인터페이스로 분리한다면 기존의 기능을 그대로 유지하면서도, 위의 문제를 해결할 수 있다.

### 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

    추상성이 높고 안정적인 고수준의 클래스는, 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙이다. 일반적으로 객체지향의 인터페이스를 통해서 이 원칙을 준수할 수 있게 된다.

    일반적으로 프로그램 설계 시 클래스는 구현하려는 인터페이스만을 바라보고 구현이 된다. 만약 해당 인터페이스를 가지고 구현한 클래스가 여러개인 경우, 클래스를 교체하더라도, 기존의 코드를 그대로 유지하여 사용하는 것이 가능하다.

    예시로는 JPA 의 경우 JDBC Driver 인터페이스를 토대로, MySQL , H2 , MariaDB 등의 다수의 DB Driver 를 가지고 있으며, 만약 서비스에 사용하는 DB 가 변경되는 경우, 기존의 DB Driver 만 변경해주면 기존 구현한 코드 (클라이언트)를 고치지않아도 기능을 그대로 사용할 수 있다. 이는 의존성 역전 원칙을 잘 적용시킨 케이스라고 볼 수 있다.