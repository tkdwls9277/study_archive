디자인 패턴 1일차
===

01. 디자인 패턴이란?
---

프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나로, 과거의 소프트웨어 개발 과정에서 발견된

설계의 노하우를 축적해 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.

----------------------
<br>
디자인의 원칙
---

애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시키는 것이다.

→  바뀌는 부분을 따로 뽑아서 캡슐화시킨다. 

그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다.

구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.

→ "상위 형식에 맞춰서 프로그래밍 한다"는 것을 뜻함.

```C#
Dog d = new Dog();
d.짖기();
Cat c = new Cat();
c.야옹();

Animal animal = new Dog();
animal.소리내기();
or
Animal animal = new Cat();
animal.소리내기();
```

이렇게 되면 짖기() 라는 기능의 구현은 소리내기() 함수를 활용하여 짖기()에 대한 내용을 구현할 수 있고,

고양이의 야옹 소리를 소리내기() 함수를 활용하여 야옹() 으로 적용할 수 있다.

------------------------------------
<br>
02. 디자인패턴의 필요성
===

디자인패턴의 탄생
---

시스템은 다양한 이유로 끊임없이 변화하기 때문에 새로운 버전이 자주 빠르게 바뀐다. 

+ 바뀔때마다 쉽게 수용할 수 있게 하기 위해서 등장하게 됨.  

변화에 쉽게 대처하기 위해 디자인패턴이 필요하다.

끊임 없이 변하는 이유는?

- 불충분한 요구사항 정의
- 기능의 추가
- 설계의 결함
- 기술 환경의 변화


<br>
디자인패턴을 적용하면 뭐가 좋아지나
---

변화에 쉽게 대응 할 수 있다.

쉽다는 것은 개발 시간 및 테스트 시간이 단축된다는 의미로 해석 할 수 있다.

이미 개발해놓은 기능을 재사용하면 개발시간이 단축된다.

조금만 수정해서 오류없이 배포한다면 이보다 좋을 순 없다.

- 설계 변경 요청에 대한 유연한 대처를 가능케 한다.

  변화에 대처하는 시간을 줄일 수 있다.

- 모듈화, 역할별 분리로 재사용성이 향상된다.

  이미 만들어진 기능을 사용하면 개발시간을 줄일 수 있다.

### 그러나

개발시간은 줄일 수 있지만, 설계시간, 초기 개발시간은 늘어난다.

+ 처음 적용할 시기에는 3일 → 2 ~ 3주 소요될 수 있다.



### 그렇더라도 

장기적으로는 시간비용이 줄어 든다.



## Q&A

**Q1. 디자인 패턴이 그렇게 좋다면 왜 디자인 패턴 라이브러리 같은건 없는지? 라이브러리가 있으면 편할텐데...**

A. 디자인 패턴은 라이브러리보다 높은 단계에 속한다. 

디자인 패턴은 클래스와 객체를 구성하여 어떤 문제를 해결하는 방법을 제공하는데, 그러나 디자인을 특정 

애플리케이션에 맞게 적용하는 것은 개발자들이 해야할 일이다.



**Q2. 라이브러리나 프레임워크도 디자인 패턴이 아닌가?**

A. 프레임워크나 라이브러리는 디자인 패턴이 아니다. 개발자들이 각자의 코드에 링크시켜 쓸 수 있는 특정 구현을 

제공할 뿐이다. 물론 라이브러리나 프레임워크를 구현하는 과정에서 디자인 패턴을 사용하는 경우도 있다. 

그리고 그런 경우에는 일단 디자인 패턴을 이해하고 나면 디자인 패턴을 바탕으로 만들어진 API를 쉽게 이해할 수

있다는 장점이 있다.

---------------------------------------
<br>
03. 관련 기술 및 용어
===

Constructor(생성자)
---

객체 지향 프로그래밍에서 객체의 초기화를 담당하는 서브루틴을 가리킨다. 
생성자는 객체가 처음 생성될 때 호출되어 멤버 변수를 초기화하고, 필요에 따라 자원을 할당하기도 한다. 객체의 생성 시에 호출되기 때문에 생성자라는 이름이 붙었다.

생성자는 대체로 멤버 함수와 같은 모양을 하고 있지만, 값을 반환하지 않는다는 점에서 엄밀한 의미의 함수는 아니다.

생성자, class의 생성(메모리 생성), class의 초기화

```c#
public class Taxi : Car 
{
     public Taxi()
     {
     }
     public void Forward() {
          // 빠르게 앞으로...
     }
     public override void Backward() {
          // 택시는 특별 히 후진도 빠르게...
     }
}
```

<br>
Inheritance(상속)
---

상위 클래스(super class)의 모든 것을 하위 클래스(sub class)가 물려받아 내 것처럼 사용함을 의미한다. 이때 물려주는 클래스를 상위 클래스 또는 부모 클래스라고 하고, 물려받는 클래스를 하위 클래스 또는 자식 클래스라고 한다.

피터 코드(Peter Coad)는 상속의 오용을 막기 위해 상속의 사용을 엄격하게 제한하는 규칙들을 만들었다.

5가지의 규칙이 있으며, 어느 하나라도 만족하지 않는다면 상속을 사용하지 않아야 한다.

- 자식 클래스와 부모 클래스 사이는 '역할 수행(is role played by)' 관계가 아니어야 한다.
- 한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 절대 없어야 한다.
- 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.
- 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다.
- 자식 클래스가 역할(Role), 트랜잭션(Transaction), 디바이스(Device) 등을 특수화(Specialization)해야 한다.

>  디자인 패턴은 상속의 개념을 사용하지만, 단순히 기능만을 사용하기 위해서는 상속을 받아서는 안된다.

<br>
Encapsulation(캡슐화)
---

객체의 자료와 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것.

캡슐화된 객체의 행위는 외부에서 볼 때는 실제가 아닌 추상적인 것이 되므로 정보 은닉(information hiding) 개념이 지켜진다.

정보 은닉을 통해 다른 객체로부터 접근할 수 있는 것은 메시지 전달을 통해 간접적으로 자료에 접근하지만, 객체 자료에는 직접적으로 접근할 수 없다.

- 데이터 + 관련 기능 묶기
- 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고 내부구현을 변경할 수 있는 유연함.
- 정보은닉 의미를 포함한다.
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
- 외부에 영향없이 객체 내부 구현 변경가능
- 기능에 대한 이해를 높인다.(의도를 파악하는데 도움을 준다.)

<br>
Abstraction(추상화)
---

필요한 부분만을 표현할 수 있고 불필요한 부분을 제거하여 간결하고 이해하기 쉽게 만드는 작업.

이 기법은 복잡한 문제나 시스템을 이해하는 데 중요한 요소이다.

반드시 어떤 일을 해야 한다. (추상화)

그러나 일을 어떻게 할지는 각자 알아서 한다. (일반화, 구체화)


<br>
Abstract Class(추상 Class)
---

완성되지 않은 Class. 완성은 하위 Class가 한다.

Interface가 접점/약속 이라면 abstract Class는 약속 + 약속에 대한 내용까지 정의 할 수 있다.

```c#
public abstract class Car : ICarDrive
{
     public virtual void Backward() {
          // 특별한 경우가 아니면 후진은 천천히...
     }
}

public class Bus : Car 
{
     public void Forward() {
          // 천천히 앞으로...
     }
}

public class Taxi : Car 
{
     public void Forward() {
          // 빠르게 앞으로...
     }
     public override void Backward() {
          // 택시는 특별 히 후진도 빠르게...
     }
}
```

> 클래스, 메소드를 모두 추상화할 수 있지만, 추상클래스는 추상화 할 수 없다.
> 추상클래스는 독립적으로 인스턴스를 생성할 수 없음 -> 불분명하기 때문에 정확한 의미를 할당할 수 없다.


<br>
Interface(인터페이스)
---

프로그램소스(class)간의 접점, 약속

모든 자동차는 전진과 후진이 되어야한다. 전/후진이 안되면 그게 무슨 자동차냐!

그런데, 전/후진이 얼마나 빠른지 성능은 자동차 마다 다르겠지.

```c#
// 자동차 운전 interface

// 모든 자동차는 전진과 후진 기능이 있어야 한다.

public interface ICarDrive
{
    public void Forward();
    public void Backward();
}
public class Bus : ICarDrive
{
     public void Forward() {
          // 천천히 앞으로...
     }
     public void Backward() {
          // 천천히 뒤로...
     }
}
public class Taxi : ICarDrive
{
     public void Forward() {
          // 빠르게 앞으로...
     }
     public void Backward() {
          // 빠르게 뒤로...
     }
}
```

> 추상클래스와 인터페이스간의 차이점<br>
> 추상클래스는 다중 상속이 불가능<br>
> 인터페이스는 다중 상속이 가능

<br>

### 인터페이스 쉽게 만드는 방법
* 오른쪽 클릭해서 "빠른작업및 리팩토링" >> "인터페이스추출"
<br><br>

Override(오버라이드)
---

부모의 메서드를 무시하고 자식이 대체한다.

부모의 추상메서드를 자식이 구체화 한다.

```c#
public class Taxi : Car 
{
     public void Forward() {
          // 빠르게 앞으로...
     }
     public override void Backward() {
          // Car에서는 후진은 천천히 하라고 했지만, 나는 총알 택시라 특별하니 후진도 빠르게...
     }
}
```

> 부모가 정해놓은 기능을 활용하여 조금 다르게 사용할 수 있는 기능. <br>
> ex) 부모의 ''걷기'' -> 나의 ''걷기'' : 다른 방식으로 걷기(빠르게, 느리게, 앞으로, 뒤로 등...)


<br>
Loose coupling(약결합, 느슨한 결합, 느슨한 의존성)
---

시스템의 각 구성 요소가 자기들끼리의 정의에 대해서 갖고 있는 지식을 서로 공유하거나 이용하지 않는 상태를 말한다.

두 객체가 느슨하게 결합되어 있다는 것은, 그 둘이 상호작용을 하긴 하지만 서로에 대해서 서로 잘 모른다는 것을 의미한다.

 1000원을 줄 테니 빵을 내놔라.

니가 만들어오든, 사오든 나는 관심없다.


<br>
UML(Unified Modeling Language)
---

클래스간의 관계를 기호로서 표현하는 규칙

| 접근자    | 표시 | 설명                                         |
| --------- | ---- | -------------------------------------------- |
| public    | +    | 어떤 클래스에서든 접근 가능                  |
| private   | -    | 자기 클래스 에서만 접근 가능                 |
| protected | #    | 상속 관계에 있는 하위 클래스에서만 접근 가능 |

<br>

-------------------------------------------
<br>
04. 디자인패턴의 철학
===

역할별 분리
---

각 조각 역할을 단순 명료하게 할당한다.

- 전체 로직을 한 덩어리로 만들지 않는다.

- 로직을 역할별 객체로 분리한다 .

- 각 객체는 단순 명료하게 요약될 수 있는 역할이 있어야 한다 .

- 그 객체의 메소드는 요약된 역할에 포함되는 일만 수행해야 한다 .

- 필요한 객체들을 선택하여 조립하여 전체 로직을 구현한다.

  

얻는 이점
---

특정 기능을 보완하거나 수정할 때 소스 전체를 분석할 필요 없이 블록별로 나뉘어진 기능만 분석하고 수정을 하면된다. 하나를 고쳤을 때 다른곳에서 발생할 수 있는 버그의 발생률을 최소화 할 수 있다.  

덩어리째 기능을 사용할 수록 재사용할 수 있는 확률이 높아진다. 비슷한 내용의 코드를 이곳 저곳에 작성할 필요 없이 개발할 수 있다.   



표준화
---

많은 조각을 여러 경우로 조합하기 위해 연결고리를 표준화 한다.

- 객체들을 조립할 수 있으려면 객체들이 만나는 부분(인터페이스)의 표준이 필요하다
- 조립식 객체들은 이 표준을 준수해서 만들어져야 한다

> 굉장히 중요한 요소이다. 서로 조합할 수 있도록 구조에 맞아야 한다. 서로 다른 구조를 갖게 되면
> 조합하기에 까다롭다. 
> ex) 레고 조립



계층화
---

조각간의 계층을 설정하여 각 조각의 분류를 구분한다.

- 주요로직 계층

  어플리케이션의 전체 로직의 흐름을 구현한다

  단위 작업 계층의 메소드들을 호출하여 전체 로직을 구현한다

  세부 로직을 구현하면 안된다

  자료구조에 직접 접근하면 안된다

- 단위작업 계층

  어플리케이션의 세부 로직을 구현한다

  자료구조에 직접 접근한다

- 유틸리티 계층

  어플리케이션과 무관한 유용한 공통 기능을 구현한다

  예: linked list 와 같은 자료구조 클래스 string 클래스, date time 클래스

> 디자인패턴의 종류는 현재 이 시점에도 무궁무진하게 생성되고 있다. 

<br>

---------------------------------------------
<br>
05. 객체 지향적 설계 원칙
===

SRP(Single Responsibility Principle) : 단일 역할 원칙
---

클래스는 단 한 개의 역할을 가져야 한다.

클래스는 단 하나의 역할을 져야하며 클래스를 변경하는 이유는 단 하나의 이유여야 한다.

나중에 코드변화를 불러올 수 있기 때문이다. 역할이 N가지이상 있으면 바뀔수 있는 부분이 N가지 이상이 된다.

테스트 범위를 줄일 수 있다.

여러가지 기능을 처리하는 클래스 보다 재사용성이 높아진다.



OCP(Open-Closed Principle) : 개방-폐쇄 원칙
---

클래스는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

기존 기능의 수정없이, 기능을 재사용하거나 확장 할 수 있도록 한다.

변하지 않아야 되는 것과 변하는(변해도 되는) 것에 대해 구분한다.


> 모든 디자인 패턴에 적용되는 원칙. <br>
> 특정 기능을 수정할 수 없게 막아두는 원리(꼭 필요하고 중요해서 정해 놓은 규칙) 그외 개방 부분은 <br>
> 비즈니스 로직에 따라 수정할 수 있도록 해야한다. 



LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
---

부모와 자식클래스 사이의 행위가 일관성이 있어야 한다.

상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

하위 클래스가 상위 클래스의 기능을 넘보면 안된다.



ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
---

자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.

즉, 하나의 거대한 인터페이스 보다는 여러 개의 구체적인 인터페이스가 낫다는 것을 의미한다.

SRP는 객체의 단일 책임을 뜻한다면, ISP는 인터페이스의 단일 책임을 의미한다고 보면 된다.

> 인터페이스란 약속의 나열인데, 인터페이스를 애매하게 이것저것 섞어서 사용하지 않아야 한다.


DIP(Dependency Inversion Principle) : 의존성 뒤집기 원칙
---

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 

저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야한다.

**"추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않도록 한다."**

DIP는 의존 관계를 맺을 때 변하기 쉬운 것 또는 자주 변화하는 것보다는

변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 원칙이다.

잘 변하지 않는 것? -> interface, abstract class (추상클래스 인터페이스)

잘 변하는 것 ? -> concrete class (구성클래스)

> OCP와 비슷한 원칙.
>
> 의존하는 객체에 관심을 둘지 의존받는 객체에 관심을 둘지에 대한 원칙이다. 
>
> → 구상 클래스처럼 구체적인 것이 아닌 추상 클래스나 인터페이스와 같이 추상적인 것에  
>
> 의존하는 코드를 만들어야 한다.

<br>

-----------------------------
<br>
06. 디자인패턴의 종류
===

| 패턴명                               | 설명                                                         | 패턴 예시                                                    |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 생성패턴 <br />(Creational Patterns) | 객체를 생성하는데 관련된 패턴.<br />객체가 생성되는 과정에 유연성을 높이고, <br />코드의 유지가 쉬워진다. | **factory method**<br />abstraction factory<br />singleton<br />prototype<br />builder |
| 구조패턴<br />(Structural Patterns)  | 프로그램의 구조에 관련된 패턴.<br />자료구조나 인터페이스 구조 등 프로그램의 <br />구조를 설계하는데 많이 활용된다. | adapter<br />composite<br />bridge<br />**decorator**<br />facade<br />flyweight<br />proxy |
| 행동패턴<br />(Behavioral Patterns)  | 반복적으로 사용되는 객체들의 상호작용데<br />대한 패턴.      | template method<br />interpreter<br />iterator<br />observer<br />strategy<br />visitor<br />chain of responsibility<br />**command**<br />mediator<br />state<br />memento |

<br>

---------------------------------
<br>
07. 팩토리 메서드 패턴
===

팩토리 메서드 패턴이란
---

생성되는 객체에 대한 결정을 서브클래스가 할 수 있도록 객체 생성인터페이스를 제공한다.

- 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정
- 팩토리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기게 된다.

- Product

  팩토리 메서드가 생성하는 객체의 인터페이스를 정의.

- ConcreteProduct

  Product 클래스에 정의된 인터페이스를 실제로 구현한 클래스.

- Creator

  Product 타입의 객체를 반환하는 팩토리 메서드를 가진 클래스.

  템플릿 메서드인 anOperation() 을 통해 팩토리 메서드가 호출되어 ConcreteProduct 인스턴스가 생성된다.

- ConcreteCreator

  팩토리 메서드를 오버라이드하여 구현한 클래스로 ConcreteProduct 인스턴스를 생성한다.



사용목적 및 용도, 장점
---

객체의 생성을 한군데에서 관리를 할수가 있다. (ConcreteCreator 부분에서만 생성코드를 넣는다. )

- 동일한 인터페이스 구현으로 새로운 객체가 추가되더라도 소스의 수정의 거의 없다.
- 객체를 여러군데에서 생성을 각자하면 동일한 생성을 보장 못하지만, 한군데에서 관리하게 되면 동일한 생성을 보장한다.
- 불필요한 의존성을 없앨 수 있다.



"new" 의 함정
---

"new"는 "구상 객체"를 뜻한다. new를 사용하는 것 자체가 구상 클래스의 인스턴스를 만드는 것이다. 

이로 인해 "변화"가 찾아왔을 때 슬기롭게 대처할 수 없다. 코드를 하나씩 확인하고 추가 또는 제거해야 한다.

ex) 

```c#
Pizza orderPizza(String type) {
   Pizza pizza;

   // <Before>
   if (type.equals("cheese")){
      pizza = new CheesePizza();
   }
   else if (type.equals("greek")){
      pizza = new GreekPizza();
   }
   else if (type.equals("pepperoni")){
      pizza = new PepperoniPizza();
   }
   // <After>
   /* 기존 분기처리 된 부분을 팩토리 메소드 패턴을 적용하면 기존 소스코드의 수정 없이 앞으로 발생하게 
      되는 변화에 대처할 수 있다. */
   pizza = factory.createPizza(type);

   pizza.prepare();
   pizza.bake();
   pizza.cut();
   pizza.box();
   return pizza;
}
```



인터페이스에 맞춰서 코딩을 하면 "변화"가 찾아오더라도 "다형성" 덕분에 어떤 클래스든 특정 인터페이스만 

구현하면 슬기롭게 대처할 수 있다. 



객체의 선언 
---

#### var, Object, dynamic 에 대한 이해

```c#
GuroPizzaStore nyStore2 = new GuroPizzaStore();
PizzaStore nyStore = new GuroPizzaStore();
var nyStore3 = new GuroPizzaStore();
Object nyStore4 = new GuroPizzaStore();
dynamic dynamic = new GuroPizzaStore();
```

**var**는 할당 시에 데이터 타입을 정해준다. 값 자체가 정해져 있지 않기 때문 **리턴 타입**으로는 사용할 수 없다. var를 사용하게 되면 PizzaStore가 담기는 것이 아닌 GuroPizzaStore 가 담기기 때문에 두가지 모두를 사용할 수 없게 된다. 따라서 디자인 패턴에서는 선언문 사용시 var의 사용은 지양한다.

**Object**를 사용하게 되면 Boxing, UnBoxing이 일어나서 느려진다.

**dynamic**은 런타임시에 결정 지어주므로 리턴타입으로는 사용할 수는 있지만 권고하지 않는다.

<br>

---------------------------
<br>
08. 데코레이터 패턴
===

데코레이터 패턴이란
---

객체에 추가적인 요건을 동적으로 첨가할 수 있다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

- 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다.

- Component

  기본 기능을 뜻하는 ConcreteComponent와 추가 기능을 뜻하는 Decorator의 공통 기능을 정의

  즉, 클라이언트는 Component를 통해 실제 객체를 사용함

- ConcreteComponent

  기본 기능을 구현하는 클래스

- Decorator

  많은 수가 존재하는 구체적인 Decorator의 공통 기능을 제공

- ConcreteDecoratorA, ConcreteDecoratorB

  Decorator의 하위 클래스로 기본 기능에 추가되는 개별적인 기능을 뜻함

  ConcreteDecorator 클래스는 ConcreteComponent 객체에 대한 참조가 필요한데, 이는 Decorator 클래스에서 Component 클래스로의 ‘합성(composition) 관계’를 통해 표현됨

> 상속의 개념이 아닌 전달식으로 추가적인 옵션을 사용하는 구조. 특정 정보를 쟁여뒀다가 + @ 해주는 개념
> -> 상하 계층적인 구조가 아닌 좌우 계층을 나뉘여져 있어서 필요한 기능만 뽑아쓸 수 있는 구조



사용목적 및 용도, 장점
---

클래스의 기능들이 동적으로 변경될 소지가 있을때 사용한다.

- 기존 기능에 추가로  새로운 기능이 추가가 될 소지가 있을때사용한다.
- 기능 확장이 필요할 때 상속의 대안으로 사용한다.

 

단점
---

기능을 확장하기 위해서는 보통 상속을 받아서 사용하는데 데코레이터 패턴에서는 그런 기능

(부모가 제공해주는 기능에 덧붙여서 사용)이 제공되지 않기 때문에 직접 제어를 해줘야하는 번거로움이 따른다. 



소스코드 예시
---

```c#
<Before>
Pizza pizza = new CheesePizza();
string[] decos = new string[3] { "Shrimp", "Beef", "Shrimp" };
foreach(var deco in decos) {
    switch (deco) {
        case "Shrimp": {
            var cost = pizza.Cost() + 2000;
            break;
        }
        case "Beef": {
            var cost = pizza.Cost() + 3000;
            break;
        }
        // 옵션이 늘어나게 된다면 케이스구문이 계속해서 늘려줘야 하는 문제점을 해결할 수 있다.
    }
}
    
<After>
Pizza pizza1 = new CheesePizza();
Console.WriteLine($"{pizza1.Description} $ {pizza1.Cost()}");
--> CheesePizza $ 8900

Pizza pizza2 = new PepperoniPizza();
pizza2 = new Shrimp(pizza2);
pizza2 = new Shrimp(pizza2);
pizza2 = new Beef(pizza2);

Console.WriteLine($"{pizza2.Description} $ {pizza2.Cost()}");
--> PepperinoPizza, Shrimp, Shrimp, Beef $ 15900
```

쟁여둔 금액 + 추가된 금액을 계산해서 돌려줌.

→ 피자(8900) + 새우(2000) + 새우(2000) + 소고기(3000)

주의점은 새우, 소고기는 같은 콤포넌트를 상속받고 있어야 위와같은 패턴을 구현할 수 있다는 것이다.
추가로 인스턴스화 시켜주더라도 본질은 변하지 않아야 한다.( pizza2가 페퍼로니 피자라는 논리적인 성질)

--> 아무리 추가토핑이 들어가더라도 페퍼로니피자라는 사실은 변함이 없다. 없어야 한다.

결국, 피자라는 공통적인 콤포넌트를 상속받고 있어야 위와같은 패턴을 구현할 수 있다.
